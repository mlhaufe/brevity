{"version":3,"file":"index.mjs","mappings":"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","sources":["webpack://@mlhaufe/brevity/webpack/bootstrap","webpack://@mlhaufe/brevity/webpack/runtime/define property getters","webpack://@mlhaufe/brevity/webpack/runtime/hasOwnProperty shorthand","webpack://@mlhaufe/brevity/./src/BoxedMultiKeyMap.mjs","webpack://@mlhaufe/brevity/./src/Data.mjs","webpack://@mlhaufe/brevity/./src/Trait.mjs","webpack://@mlhaufe/brevity/./src/memoFix.mjs"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\r\n * A MultiKey WeakMap that supports primitive keys.\r\n */\r\nexport class BoxedMultiKeyMap {\r\n    #map = new WeakMap();\r\n    #primitiveMap = new Map();\r\n    #null = Object.create(null);\r\n    #undefined = Object.create(null);\r\n\r\n    /**\r\n     * Boxes a primitive key if necessary.\r\n     * @param {any} key The value to box\r\n     * @returns {any} The boxed value or the original value if it is already an object\r\n     */\r\n    #objKey(key) {\r\n        if (key === null) return this.#null;\r\n        if (key === undefined) return this.#undefined;\r\n        if (typeof key === 'number')\r\n            return this.#primitiveMap.get(key) ?? this.#primitiveMap.set(key, new Number(key)).get(key);\r\n        if (typeof key === 'string')\r\n            return this.#primitiveMap.get(key) ?? this.#primitiveMap.set(key, new String(key)).get(key);\r\n        if (typeof key === 'boolean')\r\n            return this.#primitiveMap.get(key) ?? this.#primitiveMap.set(key, new Boolean(key)).get(key);\r\n        if (typeof key === 'bigint')\r\n            return this.#primitiveMap.get(key) ?? this.#primitiveMap.set(key, Object(key)).get(key);\r\n        // currently needed due to the following being at Stage 3:\r\n        // https://github.com/tc39/proposal-symbols-as-weakmap-keys\r\n        if (typeof key === 'symbol')\r\n            return this.#primitiveMap.get(key) ?? this.#primitiveMap.set(key, Object(key)).get(key);\r\n        // This may be a mistake in general, but for use in the Data module it is necessary\r\n        // for supporting strict equality\r\n        if (typeof key === 'function' && key.toString().startsWith('(')) {\r\n            const strFunc = key.toString();\r\n            return this.#primitiveMap.get(strFunc) ?? this.#primitiveMap.set(strFunc, key).get(strFunc);\r\n        }\r\n\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * Checks if the map has a value for the given keys.\r\n     * @param {any[]} keys The keys to check\r\n     * @returns {any} The value for the given keys or undefined if no value exists\r\n     * @throws {TypeError} If the number of keys is less than 1\r\n     * @example\r\n     * const map = new BoxedMultiKeyMap();\r\n     * map.set(1, 2, 3, 4);\r\n     * map.get(1, 2, 3); // 4\r\n     */\r\n    get(...keys) {\r\n        const lastMap = keys.reduce((map, key) => {\r\n            if (map === undefined)\r\n                return undefined;\r\n            const objKey = this.#objKey(key);\r\n            return map.get(objKey);\r\n        }, this.#map);\r\n\r\n        if (lastMap === undefined)\r\n            return undefined;\r\n\r\n        return lastMap.get(this.#objKey(keys[keys.length - 1]));\r\n    }\r\n\r\n    /**\r\n     * Sets the value for the given keys.\r\n     * @param {any[]} keysAndValue The keys and value to set\r\n     * @returns {void}\r\n     * @throws {TypeError} If the number of keys is less than 1\r\n     * @example\r\n     * const map = new BoxedMultiKeyMap();\r\n     * map.set(1, 2, 3, 4);\r\n     * map.get(1, 2, 3); // 4\r\n     */\r\n    set(...keysAndValue) {\r\n        const keys = keysAndValue.slice(0, -1),\r\n            value = keysAndValue[keysAndValue.length - 1];\r\n\r\n        const lastMap = keys.reduce((map, key) => {\r\n            const objKey = this.#objKey(key);\r\n            if (!map.has(objKey)) {\r\n                const newMap = new WeakMap();\r\n                map.set(objKey, newMap);\r\n            }\r\n            return map.get(objKey);\r\n        }, this.#map);\r\n\r\n        lastMap.set(this.#objKey(keys[keys.length - 1]), value);\r\n    }\r\n\r\n    /**\r\n     * Deletes the value for the given keys.\r\n     * @param {any[]} keys The keys to delete\r\n     * @returns {void}\r\n     * @throws {TypeError} If the number of keys is less than 1\r\n     * @example\r\n     * const map = new BoxedMultiKeyMap();\r\n     * map.set(1, 2, 3, 4);\r\n     * map.delete(1, 2, 3);\r\n     * map.get(1, 2, 3); // undefined\r\n     * map.get(1, 2); // undefined\r\n     * map.get(1); // undefined\r\n     */\r\n    delete(...keys) {\r\n        const lastMap = keys.reduce((map, key) => {\r\n            if (map === undefined)\r\n                return undefined;\r\n            const objKey = this.#objKey(key);\r\n            if (!map.has(objKey))\r\n                return undefined;\r\n            return map.get(objKey);\r\n        }, this.#map);\r\n\r\n        if (lastMap === undefined)\r\n            return;\r\n\r\n        lastMap.delete(this.#objKey(keys[keys.length - 1]));\r\n    }\r\n\r\n    /**\r\n     * Checks if the map has a value for the given keys.\r\n     * @param {any[]} keys The keys to check\r\n     * @returns {boolean} Whether the map has a value for the given keys\r\n     * @throws {TypeError} If the number of keys is less than 1\r\n     * @example\r\n     * const map = new BoxedMultiKeyMap();\r\n     * map.set(1, 2, 3, 4);\r\n     * map.has(1, 2, 3); // true\r\n     * map.has(1, 2, 3, 4); // false\r\n     */\r\n    has(...keys) {\r\n        const lastMap = keys.reduce((map, key) => {\r\n            if (map === undefined)\r\n                return undefined;\r\n            const objKey = this.#objKey(key);\r\n            if (!map.has(objKey))\r\n                return undefined;\r\n            return map.get(objKey);\r\n        }, this.#map);\r\n\r\n        if (lastMap === undefined)\r\n            return false;\r\n\r\n        return lastMap.has(this.#objKey(keys[keys.length - 1]));\r\n    }\r\n}","import { BoxedMultiKeyMap } from \"./BoxedMultiKeyMap.mjs\";\r\n\r\nconst isObjectLiteral = obj => obj !== null && Object.getPrototypeOf(obj) === Object.prototype;\r\nconst isCapitalized = str => typeof str === 'string' && str.match(/^[A-Z][A-Za-z0-9]*$/);\r\nconst isCamelCase = str => typeof str === 'string' && str.match(/^[a-z][A-Za-z0-9]*$/);\r\n\r\nconst pool = Symbol('pool');\r\n\r\nfunction def(variants) {\r\n    if (!isObjectLiteral(variants))\r\n        throw new TypeError('variants declaration must be an object literal');\r\n\r\n    for (const [name, params] of Object.entries(variants)) {\r\n        if (!isCapitalized(name))\r\n            throw new TypeError(`variant name must be capitalized: ${name}`);\r\n        if (!Array.isArray(params))\r\n            throw new TypeError(`variant properties must be an array: ${name}`);\r\n        if (!params.every(isCamelCase))\r\n            throw new TypeError(`variant properties must be camelCase strings: ${name}: ${params}`);\r\n        if (new Set(params).size !== params.length) {\r\n            throw new TypeError(`type parameters must be unique: ${name}: ${params}`);\r\n        }\r\n        // if the type has no parameters, it is a singleton\r\n        if (params.length === 0) {\r\n            variants[name] = Object.freeze(\r\n                Object.assign(Object.create(null), ({ [variantName]: name, [isSingleton]: true }))\r\n            )\r\n        } else {\r\n            // otherwise each type becomes a constructor\r\n            const self = variants[name] = function (...args) {\r\n                const normalizedArgs = [];\r\n\r\n                if (params.length === 1) {\r\n                    if (args.length === 1) {\r\n                        const arg = args[0];\r\n                        if (!isObjectLiteral(arg)) {\r\n                            normalizedArgs.push(arg);\r\n                        } else {\r\n                            // if the object has the correct property, use it\r\n                            if (params[0] in arg) {\r\n                                normalizedArgs.push(arg[params[0]]);\r\n                            } else {\r\n                                // pass the object as is\r\n                                normalizedArgs.push(arg);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (args.length === 1) {\r\n                        const objArg = args[0];\r\n                        if (!isObjectLiteral(objArg))\r\n                            throw new TypeError(`Wrong number of arguments. expected: ${name}(${params}), got: ${name}(${args})`);\r\n                        if (Object.keys(objArg).length != params.length)\r\n                            throw new TypeError(`Wrong number of parameters. Expected: ${name}(${params}), got: ${name}(${Object.keys(objArg)})`);\r\n\r\n                        for (const param of params) {\r\n                            if (!(param in objArg))\r\n                                throw new TypeError(`Missing parameter: ${param}`);\r\n                            normalizedArgs.push(objArg[param]);\r\n                        }\r\n                    } else if (args.length === params.length) {\r\n                        normalizedArgs.push(...args);\r\n                    } else {\r\n                        throw new TypeError(`Wrong number of arguments. expected: ${name}(${params}), got: ${name}(${args})`);\r\n                    }\r\n                }\r\n\r\n                let obj = self[pool].get(...normalizedArgs);\r\n                if (obj) return obj;\r\n                obj = Object.create(self.prototype);\r\n                params.forEach((param, i) => {\r\n                    if (typeof normalizedArgs[i] === 'function')\r\n                        Object.defineProperty(obj, param, { get: normalizedArgs[i], enumerable: true });\r\n                    else\r\n                        obj[param] = normalizedArgs[i];\r\n                });\r\n                self[pool].set(...[...normalizedArgs, obj]);\r\n\r\n                return Object.freeze(obj);\r\n            }\r\n            self[pool] = new BoxedMultiKeyMap();\r\n            self.prototype = Object.freeze({ [variantName]: name, [isSingleton]: false });\r\n        }\r\n    }\r\n\r\n    variants[isData] = true;\r\n\r\n    return Object.freeze(variants);\r\n}\r\n\r\nexport const variantName = Symbol('variantName'),\r\n    isData = Symbol('isData'),\r\n    isSingleton = Symbol('isSingleton');\r\n\r\n/**\r\n * Data types with named parameters and immutable objects.\r\n * @param {Object} variants\r\n * @returns {Object}\r\n * @example\r\n * const Color = Data({ Red: [], Green: [], Blue: [] }),\r\n *       red = Color.Red;\r\n *\r\n * const Point = Data({ Point2: ['x', 'y'], Point3: ['x', 'y', 'z'] }),\r\n *       p2 = Point.Point2({ x: 1, y: 2 }),\r\n *       p3 = Point.Point3({ x: 1, y: 2, z: 3 });\r\n *\r\n * const List = Data({ Nil: [], Cons: ['head', 'tail'] }),\r\n *       list = List.Cons({ head: 1, tail: List.Cons({ head: 2, tail: List.Nil }) });\r\n\r\n * const Peano = Data({ Zero: [], Succ: ['pred'] }),\r\n *       zero = Peano.Zero,\r\n *       succ = Peano.Succ({ pred: Peano.Zero });\r\n * \r\n * const ExtendedColor = Data(Color, { Yellow: [], Magenta: [], Cyan: [] }),\r\n *      red = ExtendedColor.Red,\r\n *      yellow = ExtendedColor.Yellow;\r\n */\r\nexport function Data(Base, variants) {\r\n    let data\r\n    if (Base && variants) {\r\n        if (!Base[isData])\r\n            throw new TypeError('Base must be a Data type');\r\n        data = Object.assign({}, Base, def(variants));\r\n    }\r\n    else if (Base && !variants) {\r\n        data = def(Base);\r\n    }\r\n    else {\r\n        throw new TypeError('Data requires at least one argument');\r\n    }\r\n\r\n    return Object.freeze(data);\r\n}\r\n\r\n","import { variantName } from './Data.mjs';\r\n\r\nexport const isTrait = Symbol('isTrait'),\r\n    all = Symbol('all'),\r\n    apply = Symbol('apply');\r\n\r\nconst protoTrait = () => { }\r\nprotoTrait[isTrait] = true;\r\nprotoTrait[apply] = function (instance, ...args) {\r\n    const name = typeof instance === 'object' && instance !== null && variantName in instance ? instance[variantName] : all,\r\n        fn = this[name] ?? this[all];\r\n    if (!fn)\r\n        throw new TypeError(`no trait defined for [all]`)\r\n\r\n    return fn.call(this, instance, ...args)\r\n}\r\n\r\n/**\r\n * Defines a trait for a data declaration.\r\n * const traitFn = Trait(traits)\r\n * const result = traitFn(dataInstance, ...args)\r\n * @overload\r\n * @param {object} traits The traits to define.\r\n * @throws {TypeError} if traits is not an object literal\r\n * @throws {TypeError} if any trait is not a function \r\n * @returns {function} a trait\r\n * @example\r\n * const List = Data({ Nil: [], Cons: ['head', 'tail'] })\r\n * const length = Trait({\r\n *     Nil() { return 0 },\r\n *     Cons({ head, tail }) { return 1 + length(tail) }\r\n * });\r\n * const { Nil, Cons } = List\r\n * // [1, 2, 3]\r\n * const xs = Cons({ head: 1, tail: Cons({ head: 2, tail: Cons({ head: 3, tail: Nil }) }) });\r\n * length(xs) // => 3\r\n *\r\n * @overload\r\n * Defines a trait for a data declaration that extends another trait.\r\n * const traitFn = Trait(baseTrait, traits)\r\n * const result = traitFn(dataInstance, ...args)\r\n * @param {object} baseTrait The trait to extend.\r\n * @param {object} traits The traits to define.\r\n * @throws {TypeError} if baseTrait is not a trait\r\n * @throws {TypeError} if traits is not an object literal\r\n * @throws {TypeError} if any trait is not a function\r\n * @returns {function} a trait\r\n * @example\r\n * const IntExp = Data({ Lit: ['value'], Add: ['left', 'right'] })\r\n * const intPrint = Trait({\r\n *     Lit({ value }) {\r\n *         return value.toString()\r\n *     },\r\n *     Add({ left, right }) {\r\n *         return `(${this[apply](left)} + ${this[apply](right)})`\r\n *     }\r\n * })\r\n * const IntBoolExp = Data(IntExp, { Bool: ['value'], Iff: ['pred', 'ifTrue', 'ifFalse'] })\r\n * const intBoolPrint = Trait(intPrint, {\r\n *     Bool({ value }) { return value.toString() },\r\n *     Iff({ pred, ifTrue, ifFalse }) {\r\n *         return `(${this[apply](pred)} ? ${this[apply](ifTrue)} : ${this[apply](ifFalse)})`\r\n *     }\r\n * });\r\n * // if (true) 1 else 0\r\n * const exp = IntBoolExp.Iff({\r\n *     pred: IntBoolExp.Bool({ value: true }),\r\n *     ifTrue: IntBoolExp.Lit({ value: 1 }),\r\n *     ifFalse: IntBoolExp.Lit({ value: 2 })\r\n * })\r\n */\r\nexport function Trait(...args) {\r\n    const { baseTrait, traits } = args.length === 1 ?\r\n        { traits: args[0] } : { baseTrait: args[0], traits: args[1] }\r\n    let localTraits = (...args) => localTraits[apply](...args)\r\n\r\n    if (baseTrait && traits) {\r\n        if (!baseTrait[isTrait])\r\n            throw new TypeError(`baseTrait must be a Trait: ${baseTrait}`)\r\n        if (typeof traits !== 'object' || Array.isArray(traits))\r\n            throw new TypeError('traits must be an object literal');\r\n        Reflect.setPrototypeOf(localTraits, baseTrait)\r\n    } else if (!baseTrait && traits) {\r\n        if (typeof traits !== 'object' || Array.isArray(traits))\r\n            throw new TypeError('traits must be an object literal');\r\n        Reflect.setPrototypeOf(localTraits, protoTrait)\r\n    } else {\r\n        throw new TypeError('Trait must be called with at least 2 arguments')\r\n    }\r\n    Object.assign(localTraits, traits);\r\n    for (const [name, trait] of Object.entries(localTraits)) {\r\n        if (typeof trait !== 'function')\r\n            throw new TypeError(`trait must be a function: ${name}`);\r\n    }\r\n\r\n    return localTraits\r\n}","import { BoxedMultiKeyMap } from \"./BoxedMultiKeyMap.mjs\";\r\nimport { Trait, apply } from \"./Trait.mjs\";\r\n\r\nconst visited = Symbol('visited');\r\n/**\r\n * Extends a trait to support the computation of a least fixed point with a bottom element and memoization\r\n * @param {Trait} trait The trait to extend\r\n * @param {any|() => any} bottom The bottom element of the least fixed point\r\n * @returns {Trait} The extended trait\r\n */\r\nexport const memoFix = (trait, bottom) => Trait(trait, {\r\n    [visited]: new BoxedMultiKeyMap(),\r\n    [apply](...args) {\r\n        const v = this[visited];\r\n        if (!v.has(...args)) {\r\n            v.set(...args, typeof bottom === 'function' ? bottom(...args) : bottom);\r\n            v.set(...args, trait[apply].apply(this, args));\r\n        }\r\n        return v.get(...args);\r\n    }\r\n})"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","BoxedMultiKeyMap","WeakMap","Map","create","this","undefined","set","Number","String","Boolean","toString","startsWith","strFunc","keys","lastMap","reduce","map","objKey","length","keysAndValue","slice","value","has","newMap","delete","isObjectLiteral","getPrototypeOf","isCapitalized","str","match","isCamelCase","pool","Symbol","def","variants","TypeError","name","params","entries","Array","isArray","every","Set","size","freeze","assign","variantName","isSingleton","self","args","normalizedArgs","arg","push","objArg","param","forEach","i","isData","Data","Base","data","isTrait","apply","protoTrait","Trait","baseTrait","traits","localTraits","Reflect","setPrototypeOf","trait","instance","fn","visited","memoFix","bottom","v"],"sourceRoot":""}