var e={d:(t,r)=>{for(var i in r)e.o(r,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:r[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{Vw:()=>l,av:()=>g,$6:()=>u,nn:()=>y,a:()=>c,b:()=>f,GA:()=>h,o0:()=>w,yP:()=>p});class r{#e=new WeakMap;#t=new Map;#r=Object.create(null);#i=Object.create(null);#n(e){if(null===e)return this.#r;if(void 0===e)return this.#i;if("number"==typeof e)return this.#t.get(e)??this.#t.set(e,new Number(e)).get(e);if("string"==typeof e)return this.#t.get(e)??this.#t.set(e,new String(e)).get(e);if("boolean"==typeof e)return this.#t.get(e)??this.#t.set(e,new Boolean(e)).get(e);if("bigint"==typeof e)return this.#t.get(e)??this.#t.set(e,Object(e)).get(e);if("symbol"==typeof e)return this.#t.get(e)??this.#t.set(e,Object(e)).get(e);if("function"==typeof e&&e.toString().startsWith("(")){const t=e.toString();return this.#t.get(t)??this.#t.set(t,e).get(t)}return e}get(...e){const t=e.reduce(((e,t)=>{if(void 0===e)return;const r=this.#n(t);return e.get(r)}),this.#e);if(void 0!==t)return t.get(this.#n(e[e.length-1]))}set(...e){const t=e.slice(0,-1),r=e[e.length-1];t.reduce(((e,t)=>{const r=this.#n(t);if(!e.has(r)){const t=new WeakMap;e.set(r,t)}return e.get(r)}),this.#e).set(this.#n(t[t.length-1]),r)}delete(...e){const t=e.reduce(((e,t)=>{if(void 0===e)return;const r=this.#n(t);return e.has(r)?e.get(r):void 0}),this.#e);void 0!==t&&t.delete(this.#n(e[e.length-1]))}has(...e){const t=e.reduce(((e,t)=>{if(void 0===e)return;const r=this.#n(t);return e.has(r)?e.get(r):void 0}),this.#e);return void 0!==t&&t.has(this.#n(e[e.length-1]))}}const i=e=>null!==e&&Object.getPrototypeOf(e)===Object.prototype,n=e=>"string"==typeof e&&e.match(/^[A-Z][A-Za-z0-9]*$/),o=e=>"string"==typeof e&&e.match(/^[a-z][A-Za-z0-9]*$/),s=Symbol("pool");function a(e){if(!i(e))throw new TypeError("variants declaration must be an object literal");for(const[t,a]of Object.entries(e)){if(!n(t))throw new TypeError(`variant name must be capitalized: ${t}`);if(!Array.isArray(a))throw new TypeError(`variant properties must be an array: ${t}`);if(!a.every(o))throw new TypeError(`variant properties must be camelCase strings: ${t}: ${a}`);if(new Set(a).size!==a.length)throw new TypeError(`type parameters must be unique: ${t}: ${a}`);if(0===a.length)e[t]=Object.freeze(Object.assign(Object.create(null),{[p]:t,[f]:!0}));else{const n=e[t]=function(...e){const r=[];if(1===a.length){if(1===e.length){const t=e[0];i(t)&&a[0]in t?r.push(t[a[0]]):r.push(t)}}else if(1===e.length){const n=e[0];if(!i(n))throw new TypeError(`Wrong number of arguments. expected: ${t}(${a}), got: ${t}(${e})`);if(Object.keys(n).length!=a.length)throw new TypeError(`Wrong number of parameters. Expected: ${t}(${a}), got: ${t}(${Object.keys(n)})`);for(const e of a){if(!(e in n))throw new TypeError(`Missing parameter: ${e}`);r.push(n[e])}}else{if(e.length!==a.length)throw new TypeError(`Wrong number of arguments. expected: ${t}(${a}), got: ${t}(${e})`);r.push(...e)}let o=n[s].get(...r);return o||(o=Object.create(n.prototype),a.forEach(((e,t)=>{"function"==typeof r[t]?Object.defineProperty(o,e,{get:r[t],enumerable:!0}):o[e]=r[t]})),n[s].set(...r,o),Object.freeze(o))};n[s]=new r,n.prototype=Object.freeze({[p]:t,[f]:!1})}}return e[c]=!0,Object.freeze(e)}const p=Symbol("variantName"),c=Symbol("isData"),f=Symbol("isSingleton");function l(e,t){let r;if(e&&t){if(!e[c])throw new TypeError("Base must be a Data type");r=Object.assign({},e,a(t))}else{if(!e||t)throw new TypeError("Data requires at least one argument");r=a(e)}return Object.freeze(r)}const h=Symbol("isTrait"),u=Symbol("all"),y=Symbol("apply"),b=()=>{};function g(...e){const{baseTrait:t,traits:r}=1===e.length?{traits:e[0]}:{baseTrait:e[0],traits:e[1]};let i=(...e)=>i[y](...e);if(t&&r){if(!t[h])throw new TypeError(`baseTrait must be a Trait: ${t}`);if("object"!=typeof r||Array.isArray(r))throw new TypeError("traits must be an object literal");Reflect.setPrototypeOf(i,t)}else{if(t||!r)throw new TypeError("Trait must be called with at least 2 arguments");if("object"!=typeof r||Array.isArray(r))throw new TypeError("traits must be an object literal");Reflect.setPrototypeOf(i,b)}Object.assign(i,r);for(const[e,t]of Object.entries(i))if("function"!=typeof t)throw new TypeError(`trait must be a function: ${e}`);return i}b[h]=!0,b[y]=function(e,...t){const r=this["object"==typeof e&&null!==e&&p in e?e[p]:u]??this[u];if(!r)throw new TypeError("no trait defined for [all]");return r.call(this,e,...t)};const m=Symbol("visited"),w=(e,t)=>g(e,{[m]:new r,[y](...r){const i=this[m];return i.has(...r)||(i.set(...r,"function"==typeof t?t(...r):t),i.set(...r,e[y].apply(this,r))),i.get(...r)}});var j=t.Vw,v=t.av,d=t.$6,O=t.nn,T=t.a,$=t.b,E=t.GA,M=t.o0,S=t.yP;export{j as Data,v as Trait,d as all,O as apply,T as isData,$ as isSingleton,E as isTrait,M as memoFix,S as variantName};
//# sourceMappingURL=index.mjs.map